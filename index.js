// Покдлючаем модули:
// Фреймворк
const Telegraf = require('telegraf');
// Парсинг
const axios = require('axios');
// Для выборки полученных данных через парсинг
const cheerio = require('cheerio');
// Для переноса приватной информации из публичного файла, в приватный
require('dotenv').config();

// Токен для управления ботом
const bot = new Telegraf(process.env.BOT_TOKEN);

// Запускается при старте бота, либо командой /start. ${ctx.message.from.first_name} для получения имени пользователя и обращения к нему. Так же можно получить и last_name
bot.start((ctx) =>
  ctx.reply(`Здравствуйте ${ctx.message.from.first_name}!
Введите Ваш вопрос, чтобы получить краткую выдержку из "Википедии", ссылку на полную статью, а так же на другие возможные значения вашего запроса.
Либо введите команду /help , для получения информации об этом боте, контактной информации и др.

Good day ${ctx.message.from.first_name}!
Work on English version in progress`)
);

// Запускается при вводе команды /help
bot.help((ctx) =>
  ctx.reply(`Контактная информация для вопросов и предложений - @alexeyinn 
Ссылка на исходный код проекта - 
В планах добавить в бота: 
Переключение между языками в рамках одного бота. 
Навигация по разделам искомой статьи прямо внутри бота. 
Сбор статистики по посещаемости.
`)
);

// 'text' реагирует на любой получаемый код формата "строка". Запускает асинхронную функцию, что бы бот успел получить запрашиваемую информацию из сети
bot.on('text', async (ctx) => {
  // Получаем что ввел пользователь
  const wiki = ctx.message.text;
  // Формируем ссылку на полную страницу с запрашиваемой информацией
  const link = `https://ru.wikipedia.org/wiki/${encodeURIComponent(wiki)}`;
  // И формируем ссылку со страницей "других значений" запрвшиваемой статьи
  const anotherLink = `https://ru.wikipedia.org/wiki/${encodeURIComponent(
    wiki
  )}_(%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)`;
  // Отправляем их пользователю
  ctx.reply(`Посмотреть другие значения слова - ${anotherLink}`);
  ctx.reply(`Посмотреть статью полностью - ${link}`);

  // Так же передаем сформированную ссылку axios'у для парсинга
  await axios
    .get(link)
    .then((response) => {
      // Передаем полученную информацию cheerio
      const $ = cheerio.load(response.data, { decodeEntities: false });
      // И отправляем пользователю, при этом выбрав, небольшой кусок статьи из первого абзаца
      ctx.reply(
        $('.mw-parser-output')
          .children('p')
          .slice(0)
          .eq(0)
          .text()
          // Регулярное выражение для удаления из статьи [1] - подобных конструкций. На которых в оригинале закрепелны гиперссылки.
          .replace(/(\[\S+\])+/g, '')
      );
    })
    // Если не отлавливать ошибки, бот будет вставать и нужен будет ручной перезапуск.
    .catch((error) => {
      // Оставил для быстрой диагностики, почему вдруг, в дальнейшем, могут пойти ошибки.
      ctx.reply(`Ошибка ${error.name}:${error.message}\n${error.stack}`);
      // Ну и подсказка для пользователя, что он просто мог ввести недействительный запрос.
      ctx.reply('Проверьте написание запроса. Возможно, вы допустили грамматическую ошибку.');
    });
});

bot.launch();
